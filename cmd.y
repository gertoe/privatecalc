/*
 * This is bison grammar for command line interface parser
 * generated by docopt.c.
 */

%{
#include <stdio.h>
#include <string.h>
#include <errno.h>

static int error;

int yyargc;
int yycurarg;
char **yyargv;

struct cli;

int yylex(struct cli *cli);
void yyerror(struct cli *cli, const char *err);
int yylex_destroy(void);

typedef struct yy_buffer_state* YY_BUFFER_STATE;
void yy_switch_to_buffer(YY_BUFFER_STATE buf);
YY_BUFFER_STATE yy_scan_string(const char *yy_str);

#define CLI_STRDUP(ptr, member, str) ({		\
	(ptr)->member = strdup(str);		\
	if (!(ptr)->member)			\
		return -ENOMEM;			\
});

#define CLI_STRDUP_ARR(ptr, member, str) ({			\
	char **newarr;						\
	size_t oldsz, num;					\
								\
	num = (ptr)->member ## _num;				\
	oldsz = sizeof(*newarr) * num;				\
	newarr = malloc(sizeof(*newarr) + oldsz);		\
	if (!newarr)						\
		return -ENOMEM;					\
	if (oldsz)						\
		memcpy(newarr, (ptr)->member ## _arr, oldsz);	\
	free((ptr)->member ## _arr);				\
	(ptr)->member ## _arr = newarr;				\
	(ptr)->member ## _arr[num] = strdup(str);		\
	if (!(ptr)->member ## _arr[num])			\
		return -ENOMEM;					\
	(ptr)->member ## _num += 1;				\
});

%}
%code requires {
#include "cmd.h"
}
%parse-param { struct cli *cli }
%lex-param { struct cli *cli }
%union {
	const char *str;
}
%define parse.error verbose

%start commands

%token <str> WORD GCD PHI V VERBOSE H HELP VERSION
%%

commands: cmd1
        | cmd2
        | cmd3
        | cmd4
        | cmd5

cmd1: GCD { cli->gcd = 1; } WORD[ref1] { CLI_STRDUP(cli, a, $<str>ref1); } WORD[ref2] { CLI_STRDUP(cli, b, $<str>ref2); }

cmd2: PHI { cli->phi = 1; } cmd2-optgrp1 WORD[ref1] { CLI_STRDUP(cli, x, $<str>ref1); }

cmd2-optgrp1:
            | cmd2-optgrp1 V { cli->v = 1; }
            | cmd2-optgrp1 VERBOSE { cli->verbose = 1; }

cmd3: cmd3-optgrp1 WORD[ref1] { CLI_STRDUP(cli, e, $<str>ref1); } WORD[ref2] { CLI_STRDUP(cli, n, $<str>ref2); }

cmd3-optgrp1:
            | cmd3-optgrp1 V { cli->v = 1; }
            | cmd3-optgrp1 VERBOSE { cli->verbose = 1; }

cmd4: cmd4-optgrp1

cmd4-optgrp1:
            | cmd4-optgrp1 H { cli->h = 1; }
            | cmd4-optgrp1 HELP { cli->help = 1; }

cmd5: VERSION { cli->version = 1; }

%%

void yyerror(struct cli *cli, const char *errstr)
{
	if (yycurarg >= yyargc)
		fprintf(stderr, "\nError: required parameter is missing\n\n");
	else
		fprintf(stderr, "\nError: %d parameter '%s' is incorrect\n\n",
			yycurarg, yyargv[yycurarg]);
	error = -1;
}

void cli_free(struct cli *cli)
{
	free(cli->a);
	free(cli->b);
	free(cli->x);
	free(cli->e);
	free(cli->n);
}

int cli_parse(int argc, char **argv, struct cli *cli)
{
	YY_BUFFER_STATE buf;

	if (argc <= 1)
		return -1;

	memset(cli, 0, sizeof(*cli));

	yycurarg = 1;
	yyargc = argc;
	yyargv = argv;

	buf = yy_scan_string(yyargv[yycurarg]);
	if (buf == NULL)
		return -1;
	yy_switch_to_buffer(buf);
	yyparse(cli);
	yylex_destroy();

	if (error)
		cli_free(cli);

	return error;
}

#ifdef MAIN_EXAMPLE
int main(int argc, char **argv)
{
	struct cli cli;
	int rc;

	rc = cli_parse(argc, argv, &cli);
	if (rc) {
		fprintf(stderr, "%s\n", cli_usage);
		return -1;
	}
	printf("'gcd' = '%d'\n", cli.gcd);
	printf("'a' = '%s'\n", cli.a);
	printf("'b' = '%s'\n", cli.b);
	printf("'phi' = '%d'\n", cli.phi);
	printf("'v' = '%d'\n", cli.v);
	printf("'verbose' = '%d'\n", cli.verbose);
	printf("'x' = '%s'\n", cli.x);
	printf("'e' = '%s'\n", cli.e);
	printf("'n' = '%s'\n", cli.n);
	printf("'h' = '%d'\n", cli.h);
	printf("'help' = '%d'\n", cli.help);
	printf("'version' = '%d'\n", cli.version);
	cli_free(&cli);

	return 0;
}
#endif
